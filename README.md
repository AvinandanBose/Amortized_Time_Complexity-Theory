
<h1 align="Center">𝑨𝒎𝒐𝒓𝒕𝒊𝒛𝒆𝒅 𝑻𝒊𝒎𝒆 𝑪𝒐𝒎𝒑𝒍𝒆𝒙𝒊𝒕𝒚 𝑻𝒉𝒆𝒐𝒓𝒚</h1>

<ul>
  
<h3>𝑰𝒕 𝒂𝒑𝒑𝒍𝒊𝒆𝒔 𝒏𝒐𝒕 𝒕𝒐 𝒂 𝒔𝒊𝒏𝒈𝒍𝒆 𝒓𝒖𝒏 𝒐𝒇 𝒂𝒍𝒈𝒐𝒓𝒊𝒕𝒉𝒎 𝒃𝒖𝒕 
𝒓𝒂𝒕𝒉𝒆𝒓 𝒕𝒐 𝒂 𝒔𝒆𝒒𝒖𝒆𝒏𝒄𝒆 𝒐𝒇 𝒐𝒑𝒆𝒓𝒂𝒕𝒊𝒐𝒏𝒔 𝒑𝒆𝒓𝒇𝒐𝒓𝒎𝒆𝒅 𝒐𝒏 
𝒕𝒉𝒆 𝒔𝒂𝒎𝒆 𝒅𝒂𝒕𝒂 𝒔𝒕𝒓𝒖𝒄𝒕𝒖𝒓𝒆 .𝑨𝒔 𝒘𝒆 𝒔𝒆𝒆 𝒊𝒏 𝒕𝒉𝒆 𝒔𝒕𝒂𝒄𝒌 
𝒑𝒓𝒆𝒗𝒊𝒐𝒖𝒔𝒍𝒚.𝑨𝒔 𝒕𝒉𝒆 𝒔𝒕𝒂𝒄𝒌 𝒈𝒆𝒕𝒔 2 𝒊𝒕 𝒈𝒆𝒕𝒔 𝒅𝒐𝒖𝒃𝒍𝒆𝒅 .</h3>
  
<h3>𝑾𝒆 𝒄𝒂𝒏 𝒕𝒆𝒓𝒎 𝒔𝒖𝒄𝒉 𝒕𝒚𝒑𝒆 𝒐𝒇 𝑺𝒕𝒂𝒄𝒌 𝒂𝒔 𝑨𝒖𝒈𝒎𝒆𝒏𝒕𝒆𝒅 𝑺𝒕𝒂𝒄𝒌
𝒘𝒉𝒆𝒓𝒆 𝑨𝒖𝒈𝒎𝒆𝒏𝒕𝒆𝒅 𝒎𝒆𝒂𝒏𝒔 𝒈𝒓𝒆𝒂𝒕𝒆𝒓 𝒊𝒏 𝒔𝒊𝒛𝒆.</h3>
  
<h3>𝑺𝒖𝒄𝒉 𝒅𝒐𝒖𝒃𝒍𝒊𝒏𝒈 𝒔𝒊𝒛𝒆 ,𝒘𝒆 𝒔𝒆𝒆 𝒊𝒏 𝒅𝒚𝒏𝒂𝒎𝒊𝒄 𝒉𝒂𝒔𝒉 𝒕𝒂𝒃𝒍𝒆
𝒅𝒂𝒕𝒂 𝒔𝒕𝒓𝒖𝒄𝒕𝒖𝒓𝒆𝒔 ,𝒘𝒉𝒆𝒓𝒆 𝒆𝒂𝒄𝒉 𝒕𝒊𝒎𝒆 𝒐𝒇 𝒐𝒗𝒆𝒓𝒇𝒍𝒐𝒘 𝒕𝒉𝒆 𝒔𝒊𝒛𝒆 
𝒊𝒏𝒄𝒓𝒆𝒂𝒔𝒆𝒔.</h3>
  
<h3>𝑨𝒄𝒄𝒐𝒓𝒅𝒊𝒏𝒈 𝑪𝒐𝒓𝒎𝒆𝒏 ,𝑨𝒎𝒐𝒓𝒕𝒊𝒛𝒆𝒅 𝑨𝒏𝒂𝒍𝒚𝒔𝒊𝒔 𝒄𝒂𝒏 𝒃𝒆 
𝒅𝒆𝒇𝒊𝒏𝒆𝒅 𝒂𝒔 𝒇𝒐𝒍𝒍𝒐𝒘𝒔:"𝑨𝒏 𝒂𝒎𝒐𝒓𝒕𝒊𝒛𝒆𝒅 𝒂𝒏𝒂𝒍𝒚𝒔𝒊𝒔 𝒊𝒔 𝒂𝒏𝒚
𝒔𝒕𝒓𝒂𝒕𝒆𝒈𝒚 𝒇𝒐𝒓 𝒂𝒏𝒂𝒍𝒚𝒔𝒊𝒏𝒈 𝒂 𝒔𝒆𝒒𝒖𝒆𝒏𝒄𝒆 𝒐𝒇 𝒐𝒑𝒆𝒓𝒂𝒕𝒊𝒐𝒏𝒔
𝒕𝒐 𝒔𝒉𝒐𝒘 𝒕𝒉𝒂𝒕 𝒕𝒉𝒆 𝒂𝒗𝒆𝒓𝒂𝒈𝒆 𝒄𝒐𝒔𝒕 𝒑𝒆𝒓 𝒐𝒑𝒆𝒓𝒂𝒕𝒊𝒐𝒏 𝒊𝒔 𝒔𝒎𝒂𝒍𝒍,
𝒆𝒗𝒆𝒏 𝒕𝒉𝒐𝒖𝒈𝒉 𝒂 𝒔𝒊𝒏𝒈𝒍𝒆 𝒐𝒑𝒆𝒓𝒂𝒕𝒊𝒐𝒏 𝒘𝒊𝒕𝒉𝒊𝒏 𝒕𝒉𝒆 𝒔𝒆𝒒𝒖𝒆𝒏𝒄𝒆
𝒎𝒊𝒈𝒉𝒕 𝒃𝒆 𝒆𝒙𝒑𝒆𝒏𝒔𝒊𝒗𝒆." </h3>
  
<h2></h2>
 <h2 align="Center">𝑹𝒆𝒂𝒍 𝑾𝒐𝒓𝒍𝒅 𝑬𝒙𝒂𝒎𝒑𝒍𝒆</h2>
  
 <ul>
   
<h3>𝑳𝒆𝒕 𝒖𝒔 𝒂𝒔𝒔𝒖𝒎𝒆 𝒕𝒉𝒂𝒕 𝑿 𝒈𝒆𝒕𝒔 𝒂 𝒔𝒂𝒍𝒂𝒓𝒚 𝒐𝒇 ₹10,000.𝑯𝒆 𝒔𝒂𝒗𝒆𝒔
 ₹2000 𝒑𝒆𝒓 𝒎𝒐𝒏𝒕𝒉,𝒘𝒉𝒊𝒄𝒉 𝒈𝒐𝒆𝒔 𝒐𝒏 𝒇𝒐𝒓 10 𝒎𝒐𝒏𝒕𝒉𝒔.
𝑰𝒏 𝑾𝒐𝒓𝒔𝒕 𝑪𝒂𝒔𝒆 𝑺𝒄𝒆𝒏𝒂𝒓𝒊𝒐:𝒊𝒇 𝒕𝒉𝒆 𝒆𝒙𝒑𝒆𝒏𝒅𝒊𝒕𝒖𝒓𝒆 𝒂𝒎𝒐𝒖𝒏𝒕𝒔 𝒕𝒐
₹15,000,𝑿'𝒔 𝒔𝒂𝒗𝒊𝒏𝒈 𝒘𝒐𝒖𝒍𝒅 𝒉𝒆𝒍𝒑 𝒕𝒐 𝒄𝒐𝒎𝒑𝒆𝒏𝒔𝒂𝒕𝒆 𝒕𝒉𝒆 𝒆𝒙𝒄𝒆𝒔𝒔
𝒆𝒙𝒑𝒆𝒏𝒅𝒊𝒕𝒖𝒓𝒆 𝒊𝒏 𝒂𝒏 𝒂𝒎𝒐𝒓𝒕𝒊𝒛𝒆𝒅 𝒎𝒂𝒏𝒏𝒆𝒓.</h3>

<h3>𝑰𝒏 𝒔𝒉𝒐𝒓𝒕,𝒍𝒊𝒌𝒆 𝒃𝒂𝒏𝒌𝒔 𝒌𝒆𝒆𝒑 𝒕𝒉𝒆 𝒂𝒄𝒄𝒐𝒖𝒏𝒕 𝒅𝒆𝒕𝒂𝒊𝒍𝒔 𝒐𝒇 𝒂 𝒄𝒖𝒔𝒕𝒐𝒎𝒆𝒓
,𝒐𝒏𝒆 𝒊𝒔 𝒓𝒆𝒒𝒖𝒊𝒓𝒆𝒅 𝒕𝒐 𝒎𝒂𝒊𝒏𝒕𝒂𝒊𝒏 𝒕𝒉𝒆 𝒂𝒄𝒄𝒐𝒖𝒏𝒕 𝒐𝒇 𝒕𝒉𝒆 𝒄𝒐𝒔𝒕 𝒐𝒇 𝒕𝒉𝒆
𝒔𝒆𝒒𝒖𝒆𝒏𝒄𝒆 𝒐𝒇 𝒐𝒑𝒆𝒓𝒂𝒕𝒊𝒐𝒏𝒔.</h3>
   
 </ul>
  
 <h2></h2>
 <h2 align="Center">   𝑶𝑩𝑺𝑬𝑹𝑽𝑨𝑻𝑰𝑶𝑵 </h2>
  
<ul>
  
<h3><li>1.𝑨𝒎𝒐𝒓𝒕𝒊𝒛𝒆𝒅 𝑪𝒐𝒔𝒕 >𝑨𝒄𝒕𝒖𝒂𝒍 𝑪𝒐𝒔𝒕.</li></h3>
<h3><li>2.𝑰𝒕 𝒈𝒊𝒗𝒆𝒔 𝒖𝒔 𝒕𝒉𝒆 𝒕𝒊𝒈𝒉𝒕 𝒃𝒐𝒖𝒏𝒅 𝒂𝒏𝒅 𝒕𝒊𝒈𝒉𝒕 𝒃𝒐𝒖𝒏𝒅 𝒊𝒔
𝒂𝒔𝒔𝒐𝒄𝒊𝒂𝒕𝒆𝒅 𝒘𝒊𝒕𝒉 𝑨𝒗𝒆𝒓𝒂𝒈𝒆 𝑪𝒂𝒔𝒆 𝑻𝒊𝒎𝒆 𝑪𝒐𝒎𝒑𝒍𝒆𝒙𝒊𝒕𝒚.</li></h3>

 <h2></h2>
 <h2 align="Center"> 𝑪𝒍𝒂𝒔𝒔𝒊𝒇𝒊𝒄𝒂𝒕𝒊𝒐𝒏 𝒐𝒇 𝑪𝒂𝒍𝒄𝒖𝒍𝒂𝒕𝒊𝒐𝒏 𝒐𝒏 𝑨𝒎𝒐𝒓𝒕𝒊𝒛𝒆𝒅 𝑨𝒏𝒂𝒍𝒚𝒔𝒊𝒔</h2>
  
  ![Screenshot (493)](https://github.com/AvinandanBose/Amortized_Time_Complexity-Theory/assets/38869235/f390922e-96a0-4010-90f4-67f05b355ce0)


 
</ul>
</ul>

<h1>
<h1 align="Center">𝑨𝒎𝒐𝒓𝒕𝒊𝒛𝒆𝒅 𝑻𝒊𝒎𝒆 𝑪𝒐𝒎𝒑𝒍𝒆𝒙𝒊𝒕𝒚-𝑨𝒈𝒈𝒓𝒆𝒈𝒂𝒕𝒆 𝑴𝒆𝒕𝒉𝒐𝒅</h1>
  
<ul>
  
<h3>𝑻𝒉𝒊𝒔 𝒊𝒔 𝒂𝒍𝒔𝒐 𝒌𝒏𝒐𝒘𝒏 𝒂𝒔 𝒕𝒉𝒆 “𝒔𝒖𝒎𝒎𝒂𝒕𝒊𝒐𝒏 𝒎𝒆𝒕𝒉𝒐𝒅”.
𝑻𝒉𝒆 𝒃𝒓𝒖𝒕𝒆 𝒇𝒐𝒓𝒄𝒆 𝒑𝒓𝒐𝒄𝒆𝒅𝒖𝒓𝒆 𝒊𝒔 𝒕𝒐 𝒄𝒂𝒍𝒄𝒖𝒍𝒂𝒕𝒆 𝑻(𝒎)
𝒘𝒐𝒓𝒔𝒕-𝒄𝒂𝒔𝒆 𝒕𝒊𝒎𝒆 𝒇𝒐𝒓 𝒂 𝒔𝒆𝒒𝒖𝒆𝒏𝒄𝒆 𝒐𝒇 𝒂𝒍𝒍 
𝒐𝒑𝒆𝒓𝒂𝒕𝒊𝒐𝒏𝒔 𝑶1,𝑶2,….,𝑶𝒎.𝑻𝒉𝒆 𝒂𝒎𝒐𝒓𝒕𝒊𝒛𝒆𝒅 𝒕𝒊𝒎𝒆 
𝒄𝒂𝒏 𝒃𝒆 𝒄𝒂𝒍𝒄𝒖𝒍𝒂𝒕𝒆𝒅 𝒂𝒔 𝒇𝒐𝒍𝒍𝒐𝒘𝒔:</h3>
  
  
<h3>
	
 ```math
	
 \begin{equation}
   \begin{split}
  
 \\
	
𝑨𝒎𝒐𝒓𝒕𝒊𝒛𝒆𝒅 \quad 𝒄𝒐𝒔𝒕 \quad 𝒑𝒆𝒓 \quad 𝒐𝒑𝒆𝒓𝒂𝒕𝒊𝒐𝒏 \quad= \\
  
  \\
	
\dfrac{𝑪𝒐𝒔𝒕 \quad 𝒐𝒇 \quad 𝒎 \quad 𝒐𝒑𝒆𝒓𝒂𝒕𝒊𝒐𝒏𝒔}{𝒎} = \dfrac{𝑻(𝒎)}{𝒎}  \\	
	
  \\
  
    \end{split}
 \end{equation}
	
```
	
</h3>
	
<h3>𝑨𝒔 𝒔𝒖𝒄𝒉 𝒐𝒑𝒆𝒓𝒂𝒕𝒊𝒐𝒏 𝒊𝒔 𝒑𝒐𝒔𝒔𝒊𝒃𝒍𝒆 𝒐𝒏𝒍𝒚 𝒊𝒏 𝑨𝒎𝒐𝒓𝒕𝒊𝒛𝒆𝒅
𝒐𝒑𝒆𝒓𝒂𝒕𝒊𝒐𝒏𝒔 𝒊𝒏 𝒅𝒚𝒏𝒂𝒎𝒊𝒄𝒂𝒍𝒍𝒚 , 𝒕𝒉𝒆 𝒕𝒂𝒃𝒍𝒆 𝒅𝒓𝒂𝒘𝒏
𝒂𝒄𝒄𝒐𝒓𝒅𝒊𝒏𝒈 𝒕𝒐 𝒄𝒐𝒔𝒕 𝒊𝒔 𝒌𝒏𝒐𝒘𝒏 𝒂𝒔
<ins>𝑫𝒚𝒏𝒂𝒎𝒊𝒄 𝑻𝒂𝒃𝒍𝒆𝒔</ins>.</h3>

![Screenshot (494)](https://github.com/AvinandanBose/Amortized_Time_Complexity-Theory/assets/38869235/f4fb44fc-7f38-4a01-8776-b83c8a072cd7)
	
![Screenshot (495)](https://github.com/AvinandanBose/Amortized_Time_Complexity-Theory/assets/38869235/615cba8a-15db-40a5-8c87-011b1e7c0fa7)
	
![Screenshot (496)](https://github.com/AvinandanBose/Amortized_Time_Complexity-Theory/assets/38869235/d832db44-fa80-4809-8d7a-80c6c87dac4c)
	
![Screenshot (498)](https://github.com/AvinandanBose/Amortized_Time_Complexity-Theory/assets/38869235/e9f8449e-c561-48c2-9fc0-00c857677bd9)


<h3>𝑯𝒆𝒓𝒆 𝒘𝒆 𝒔𝒆𝒆 𝒘𝒐𝒓𝒔𝒕 𝒄𝒂𝒔𝒆 𝒇𝒐𝒓 𝒕𝒊𝒎𝒆 𝒄𝒐𝒎𝒑𝒍𝒆𝒙𝒊𝒕𝒚 𝒇𝒐𝒓 𝒔𝒊𝒏𝒈𝒍𝒆
𝒊𝒏𝒔𝒆𝒓𝒕𝒊𝒐𝒏 ( 𝒘𝒉𝒆𝒏𝒆𝒗𝒆𝒓 𝒕𝒉𝒆𝒓𝒆 𝒊𝒔 𝒂𝒏 𝒐𝒗𝒆𝒓𝒇𝒍𝒐𝒘) = 𝑶(𝒏)</h3>
<h3>𝑯𝒆𝒏𝒄𝒆 𝒘𝒐𝒓𝒔𝒕 𝒄𝒂𝒔𝒆 𝒕𝒊𝒎𝒆 𝒄𝒐𝒎𝒑𝒍𝒆𝒙𝒊𝒕𝒚 𝒐𝒇 𝒏
𝒕𝒉 𝒊𝒏𝒔𝒆𝒓𝒕𝒊𝒐𝒏:𝒏 × 𝑶(𝒏) = 𝑶(𝒏^𝟐).</h3>

<h3>𝑻𝒉𝒆 𝒂𝒃𝒐𝒗𝒆 𝒂𝒑𝒑𝒓𝒐𝒂𝒄𝒉 𝒊𝒔 :<ins> "𝑵𝒐𝒓𝒎𝒂𝒍 𝑻𝒊𝒎𝒆 𝑪𝒐𝒎𝒑𝒍𝒆𝒙𝒊𝒕𝒚" </ins> 𝒊.𝒆. 𝑺𝒊𝒏𝒈𝒍𝒆 𝑰𝒏𝒔𝒆𝒓𝒕𝒊𝒐𝒏 : 𝑶(𝒏) 𝒂𝒏𝒅 𝒏 𝒊𝒏𝒔𝒆𝒓𝒕𝒊𝒐𝒏: 𝑶(𝒏^2)
. 𝑵𝒐𝒘 𝒄𝒂𝒍𝒄𝒖𝒍𝒂𝒕𝒊𝒏𝒈 𝑨𝒎𝒐𝒓𝒕𝒊𝒛𝒆𝒅 𝑻𝒊𝒎𝒆 𝑪𝒐𝒎𝒑𝒍𝒆𝒙𝒊𝒕𝒚 𝒊𝒏 <ins> 𝑨𝒈𝒈𝒓𝒆𝒈𝒂𝒕𝒆 𝑴𝒆𝒕𝒉𝒐𝒅 </ins>. </h3>
	
<br>
	
![Screenshot (499)](https://github.com/AvinandanBose/Amortized_Time_Complexity-Theory/assets/38869235/68eefde8-c3ea-4bca-9539-ea50aef2379d)


<h3>
	
 ```math
	
 \begin{equation}
   \begin{split}
	
𝑪𝒐𝒔𝒕(𝑪) \quad 𝒐𝒇 \quad 𝒏 \quad 𝒊𝒕𝒆𝒓𝒂𝒕𝒊𝒐𝒏𝒔 \quad =  \quad \quad \quad \quad \quad \quad \quad \\	
⟹ 𝒊 + \sum_{𝒊=𝟎}^{𝒍𝒐𝒈_𝟐(𝒏-𝟏)} 𝟐^{𝒊} = 𝟐^𝟎 + 𝟐^𝟏 + 𝟐^𝟐 +...+𝟐^{𝒍𝒐𝒈_𝟐(𝒏-𝟏)} ⟹𝑶(𝟑𝒏 − 𝟑) = 𝑶(𝟑𝒏) = 𝑶(𝒏) \\	
	
    \end{split}
 \end{equation}
	
```

</h3>

<ul>
<ul>
<ul>
	
<li><h3> <a href="https://github.com/AvinandanBose/Amortized_Time_Complexity-Theory/blob/main/Amortized%20Time%20Complexity-Aggregate%20Method.pdf">𝑨𝒎𝒐𝒓𝒕𝒊𝒛𝒆𝒅 𝑻𝒊𝒎𝒆 𝑪𝒐𝒎𝒑𝒍𝒆𝒙𝒊𝒕𝒚-𝑨𝒈𝒈𝒓𝒆𝒈𝒂𝒕𝒆 𝑴𝒆𝒕𝒉𝒐𝒅 - 𝑰𝒏 𝑫𝒆𝒕𝒂𝒊𝒍𝒔  </a></h3></li>
	
</ul>
</ul>
</ul>

<h3>𝑨𝒍𝒕𝒆𝒓𝒏𝒂𝒕𝒊𝒗𝒆 𝒘𝒂𝒚(𝟐):</h3>
	
<h3>
	
 ```math
	
 \begin{equation}
   \begin{split}
	
\\
	
𝑰𝒇 \quad 𝒘𝒆 \quad 𝒔𝒆𝒆 \quad 𝒕𝒉𝒆 \quad 𝒔𝒆𝒓𝒊𝒆𝒔 \quad = 𝟐^𝟎 + 𝟐^𝟏 + 𝟐^𝟐 + 𝟐^𝟑 + ⋯ \\
	
\\
	
⟹ 𝟐^{𝒍𝒐𝒈_𝟐(𝟏)} +  𝟐^{𝒍𝒐𝒈_𝟐(𝟐)} + 𝟐^{𝒍𝒐𝒈_𝟐(𝟒)} + 𝟐^{𝒍𝒐𝒈_𝟐(𝟖)} + ⋯ + 𝟐^{𝒍𝒐𝒈_𝟐(𝟐𝒏)}  \\
	
\\
	
⟹ 𝟐^{𝒍𝒐𝒈_𝟐(𝟏)} + + \sum_{𝒊=1}^{𝒏} 𝟐^{𝒍𝒐𝒈_𝟐(𝟐i)}  ⟹𝑶(𝟒𝒏 − 𝟏) = 𝑶(𝟒𝒏) = 𝑶(𝒏) \\	
	
\\
	
    \end{split}
 \end{equation}
	
```

</h3>

<ul>
<ul>
<ul>
	
<li><h3> <a href="https://github.com/AvinandanBose/Amortized_Time_Complexity-Theory/blob/main/Amortized%20Time%20Complexity-Aggregate%20Method.pdf">𝑨𝒎𝒐𝒓𝒕𝒊𝒛𝒆𝒅 𝑻𝒊𝒎𝒆 𝑪𝒐𝒎𝒑𝒍𝒆𝒙𝒊𝒕𝒚-𝑨𝒈𝒈𝒓𝒆𝒈𝒂𝒕𝒆 𝑴𝒆𝒕𝒉𝒐𝒅 - 𝑰𝒏 𝑫𝒆𝒕𝒂𝒊𝒍𝒔  </a></h3></li>
	
</ul>
</ul>
</ul>
	
<h3>𝑨𝒍𝒕𝒆𝒓𝒏𝒂𝒕𝒊𝒗𝒆 𝒘𝒂𝒚(3):</h3>
	
<h3>
	
 ```math
	
 \begin{equation}
   \begin{split}
	
\\
	
𝑰𝒇 \quad 𝒘𝒆 \quad 𝒔𝒆𝒆 \quad 𝒕𝒉𝒆 \quad 𝒔𝒆𝒓𝒊𝒆𝒔 \quad = 𝟐^𝟎 + 𝟐^𝟏 + 𝟐^𝟐 + 𝟐^𝟑 + ⋯ \\
	
\\
	
⟹ 𝑾𝒆 \quad 𝒈𝒆𝒕 \quad 𝒂 \quad 𝒈𝒆𝒐𝒎𝒆𝒕𝒓𝒊𝒄 \quad 𝒔𝒆𝒒𝒖𝒆𝒏𝒄𝒆  \quad =  \\
	
\\
	
⟹ 𝟏+𝟐+𝟒+𝟖....+ \dfrac{𝒏}{𝟒} +  \dfrac{𝒏}{𝟐} +  𝒏 = 𝒏 + \dfrac{𝒏}{𝟐} + \dfrac{𝒏}{𝟒} +...𝟖+𝟒+𝟐+𝟏 \\
	
= 𝑶(𝟐𝒏-𝒏(\dfrac{𝟏}{𝟐})^𝒏 ) = 𝑶(𝟐𝒏) = 𝑶(𝒏) \\	
	
\\
	
    \end{split}
 \end{equation}
	
```

</h3>

<ul>
<ul>
<ul>
	
<li><h3> <a href="https://github.com/AvinandanBose/Amortized_Time_Complexity-Theory/blob/main/Amortized%20Time%20Complexity-Aggregate%20Method.pdf">𝑨𝒎𝒐𝒓𝒕𝒊𝒛𝒆𝒅 𝑻𝒊𝒎𝒆 𝑪𝒐𝒎𝒑𝒍𝒆𝒙𝒊𝒕𝒚-𝑨𝒈𝒈𝒓𝒆𝒈𝒂𝒕𝒆 𝑴𝒆𝒕𝒉𝒐𝒅 - 𝑰𝒏 𝑫𝒆𝒕𝒂𝒊𝒍𝒔  </a></h3></li>
	
</ul>
</ul>
</ul>
	
<h3>𝑻𝒉𝒆𝒓𝒆𝒇𝒐𝒓𝒆 𝑨𝒎𝒐𝒓𝒕𝒊𝒛𝒆𝒅 𝒄𝒐𝒔𝒕 =</h3>
	
<h3>
	
 ```math
	
 \begin{equation}
   \begin{split}
	
\dfrac{𝑶(𝒏)}{𝒏} =𝟏	

	
    \end{split}
 \end{equation}
	
```
</h3>
	
<h3>𝑾𝒆 𝒄𝒂𝒏 𝒘𝒓𝒊𝒕𝒆 𝚯(𝟏)𝒂𝒔 𝒊𝒕 𝒊𝒔 𝒋𝒖𝒔𝒕 𝒈𝒊𝒗𝒊𝒏𝒈 𝒖𝒔 𝒕𝒉𝒆 𝑨𝒗𝒆𝒓𝒂𝒈𝒆 𝒄𝒂𝒔𝒆 𝒄𝒐𝒎𝒑𝒍𝒆𝒙𝒊𝒕𝒚.	</h3>
	
<h3><ins>𝑬𝒙𝒂𝒎𝒑𝒍𝒆 𝟐</ins>: 𝑪𝒐𝒏𝒔𝒊𝒅𝒆𝒓 𝒕𝒉𝒆 𝒇𝒐𝒍𝒍𝒐𝒘𝒊𝒏𝒈 𝒔𝒆𝒒𝒖𝒆𝒏𝒄𝒆 𝒐𝒇 𝒑𝒖𝒔𝒉 𝒂𝒏𝒅 
𝒑𝒐𝒑 𝒐𝒑𝒆𝒓𝒂𝒕𝒊𝒐𝒏 𝒐𝒑𝒆𝒓𝒂𝒕𝒊𝒐𝒏𝒔 𝒊𝒔 𝟏.𝑰𝒇 𝒕𝒉𝒆 𝒔𝒆𝒒𝒖𝒆𝒏𝒄𝒆 𝒊𝒔 𝒈𝒊𝒗𝒆𝒏 𝒂𝒔 𝒇𝒐𝒍𝒍𝒐𝒘𝒔:</h3>

 <h3>𝟏 𝒑𝒖𝒔𝒉  𝟏𝒑𝒖𝒔𝒉    𝟏𝒑𝒖𝒔𝒉    𝟑 𝒑𝒐𝒑𝒔   𝟐𝒑𝒖𝒔𝒉  𝟐𝒑𝒐𝒑𝒔   𝟐𝒑𝒖𝒔𝒉    𝟐𝒑𝒐𝒑𝒔</h3>
	
<h3>𝑺𝒐𝒍𝒖𝒕𝒊𝒐𝒏:</h3>
	
<h3>𝑨𝒔 𝒑𝒆𝒓 𝒕𝒉𝒆 𝒄𝒐𝒔𝒕 𝒈𝒊𝒗𝒆𝒏 ,𝒕𝒉𝒆 𝒄𝒐𝒔𝒕 𝒐𝒇 𝒕𝒉𝒆 𝒔𝒆𝒒𝒖𝒆𝒏𝒄𝒆 𝒘𝒐𝒖𝒍𝒅 𝒃𝒆 𝒂𝒔 𝒇𝒐𝒍𝒍𝒐𝒘𝒔:</h3>	
 
<h3>
	
 ```math
	
 \begin{equation}
   \begin{split}
	

𝒕_𝒊 = 𝟏 \quad 𝟏 \quad 𝟏 \quad 𝟑 \quad 𝟐 \quad 𝟐 \quad 𝟐 \quad 𝟐\\
	

	
    \end{split}
 \end{equation}
	
```

</h3>
	
<h3>
	
 ```math
	
 \begin{equation}
   \begin{split}
	

𝑪𝒐𝒔𝒕 =  \dfrac{𝟏+𝟏+𝟏+𝟑+𝟐+𝟐+𝟐+𝟐}{𝟖} = \dfrac{𝟏𝟒}{𝟖} =𝟏.𝟕𝟓\\
		
    \end{split}
 \end{equation}
	
```

</h3>

<ul>
<ul>
<ul>
	
<li><h3> <a href="https://github.com/AvinandanBose/Amortized_Time_Complexity-Theory/blob/main/Amortized%20Time%20Complexity-Aggregate%20Method.pdf">𝑨𝒎𝒐𝒓𝒕𝒊𝒛𝒆𝒅 𝑻𝒊𝒎𝒆 𝑪𝒐𝒎𝒑𝒍𝒆𝒙𝒊𝒕𝒚-𝑨𝒈𝒈𝒓𝒆𝒈𝒂𝒕𝒆 𝑴𝒆𝒕𝒉𝒐𝒅 - 𝑰𝒏 𝑫𝒆𝒕𝒂𝒊𝒍𝒔  </a></h3></li>
	
</ul>
</ul>
</ul>
	
</ul>

<h1>
<h1 align="Center">𝑨𝒎𝒐𝒓𝒕𝒊𝒛𝒆𝒅 𝑨𝒏𝒂𝒍𝒚𝒔𝒊𝒔 −
𝑨𝒄𝒄𝒐𝒖𝒏𝒕𝒊𝒏𝒈 𝑴𝒆𝒕𝒉𝒐𝒅</h1>

<ul>

<h3>𝑰𝒏 𝒕𝒉𝒆 𝒂𝒄𝒄𝒐𝒖𝒏𝒕𝒊𝒏𝒈 𝒎𝒆𝒕𝒉𝒐𝒅, 𝒂𝒏 𝒂𝒓𝒕𝒊𝒇𝒊𝒄𝒊𝒂𝒍 𝒄𝒐𝒔𝒕 𝒊𝒔 𝒂𝒔𝒔𝒊𝒈𝒏𝒆𝒅 𝒕𝒐 𝒆𝒗𝒆𝒓𝒚 𝒐𝒑𝒆𝒓𝒂𝒕𝒊𝒐𝒏. 𝑳𝒊𝒌𝒆 𝒃𝒂𝒏𝒌𝒔 𝒎𝒂𝒊𝒏𝒕𝒂𝒊𝒏 𝒂𝒄𝒄𝒐𝒖𝒏𝒕𝒔 𝒐𝒇 𝒕𝒉𝒆 𝒄𝒖𝒔𝒕𝒐𝒎𝒆𝒓𝒔, 𝒐𝒏𝒆 𝒎𝒖𝒔𝒕 𝒌𝒆𝒆𝒑 𝒕𝒓𝒂𝒄𝒌 𝒐𝒇 𝒕𝒉𝒆 𝒐𝒑𝒆𝒓𝒂𝒕𝒊𝒐𝒏𝒔 𝒊𝒏 𝒕𝒉𝒊𝒔 𝒄𝒂𝒔𝒆. 𝑺𝒐𝒎𝒆 𝒐𝒇 𝒕𝒉𝒆 𝒐𝒑𝒆𝒓𝒂𝒕𝒊𝒐𝒏𝒔 𝒂𝒓𝒆 𝒄𝒉𝒂𝒓𝒈𝒆𝒅 𝒆𝒙𝒕𝒓𝒂, 𝒂𝒏𝒅 𝒕𝒉𝒊𝒔 𝒆𝒙𝒕𝒓𝒂 𝒄𝒐𝒔𝒕 𝒘𝒐𝒖𝒍𝒅 𝒍𝒂𝒕𝒆𝒓 𝒖𝒔𝒆𝒅 𝒕𝒐 𝒐𝒇𝒇𝒔𝒆𝒕 𝒕𝒉𝒆 𝒄𝒐𝒔𝒕 𝒐𝒇 𝒔𝒐𝒎𝒆 𝒆𝒙𝒑𝒆𝒏𝒔𝒊𝒗𝒆 𝒐𝒑𝒆𝒓𝒂𝒕𝒊𝒐𝒏𝒔. 𝑳𝒆𝒕 `𝒄𝒊` 𝒃𝒆 𝒕𝒉𝒆 𝒂𝒄𝒕𝒖𝒂𝒍 𝒄𝒐𝒔𝒕 𝒐𝒇 𝒕𝒉𝒆  𝒐𝒑𝒆𝒓𝒂𝒕𝒊𝒐𝒏 𝒂𝒏𝒅 `𝒂𝒊`  𝒃𝒆 𝒕𝒉𝒆 𝒂𝒎𝒐𝒓𝒕𝒊𝒛𝒆𝒅 𝒄𝒐𝒔𝒕 𝒐𝒇 𝒕𝒉𝒆 𝒊𝒕𝒉 𝒐𝒑𝒆𝒓𝒂𝒕𝒊𝒐𝒏.𝑻𝒉𝒆𝒏 𝒕𝒉𝒆 𝒄𝒓𝒆𝒅𝒊𝒕 𝒊𝒔 𝒅𝒆𝒇𝒊𝒏𝒆𝒅 𝒂𝒔 𝒕𝒉𝒆 𝒅𝒊𝒇𝒇𝒆𝒓𝒆𝒏𝒄𝒆 𝒃𝒆𝒕𝒘𝒆𝒆𝒏 𝒕𝒉𝒆 𝒂𝒄𝒕𝒖𝒂𝒍 𝒂𝒏𝒅 𝒂𝒎𝒐𝒓𝒕𝒊𝒛𝒆𝒅 𝒄𝒐𝒔𝒕: </h3>

</h3>
	
<h3>
	
 ```math
	
 \begin{equation}
   \begin{split}
	

 𝑪𝒓𝒆𝒅𝒊𝒕=𝒂_𝒊-𝒄_𝒊\\
		
    \end{split}
 \end{equation}
	
```

</h3>
	
<h3>𝑭𝒐𝒓 𝒂 𝒔𝒆𝒒𝒖𝒆𝒏𝒄𝒆 𝒐𝒇 `𝒎` 𝒐𝒑𝒆𝒓𝒂𝒕𝒊𝒐𝒏𝒔,𝒕𝒉𝒆 𝒄𝒐𝒔𝒕𝒔 𝒂𝒓𝒆 𝒈𝒊𝒗𝒆𝒏 
𝒂𝒔 𝒇𝒐𝒍𝒍𝒐𝒘𝒔:</h3>

<h3>
	
 ```math
	
 \begin{equation}
   \begin{split}
	

𝒄_𝒊 = \sum_{𝒊=1}^{𝒎} 𝒄_𝒊 \quad 𝒂𝒏𝒅 \quad 𝒂_𝒊 = \sum_{𝒊=1}^{𝒎} 𝒂_𝒊\\
		
    \end{split}
 \end{equation}
	
```

</h3>
	
<h3>𝑻𝒉𝒆 𝒓𝒆𝒍𝒂𝒕𝒊𝒐𝒏 𝒃𝒆𝒕𝒘𝒆𝒆𝒏 𝒕𝒉𝒆 𝒂𝒄𝒕𝒖𝒂𝒍 𝒄𝒐𝒔𝒕𝒔 𝒂𝒏𝒅 𝒂𝒎𝒐𝒓𝒕𝒊𝒛𝒆𝒅 𝒄𝒐𝒔𝒕𝒔:</h3>

<h3>
	
 ```math
	
 \begin{equation}
   \begin{split}
	

\sum_{𝒊=1}^{𝒎} 𝒄_𝒊 \quad ≤ \quad  \sum_{𝒊=1}^{𝒎} 𝒂_𝒊\\
		
    \end{split}
 \end{equation}
	
```

</h3>

<h3>𝑻𝒉𝒆 𝒄𝒓𝒆𝒅𝒊𝒕 𝒊𝒔 𝒏𝒐𝒘 𝒈𝒊𝒗𝒆𝒏 𝒂𝒔 𝒕𝒉𝒆 𝒅𝒊𝒇𝒇𝒆𝒓𝒆𝒏𝒄𝒆 𝒃𝒆𝒕𝒘𝒆𝒆𝒏 𝒕𝒉𝒆
𝒂𝒄𝒕𝒖𝒂𝒍  𝒂𝒏𝒅 𝒂𝒎𝒐𝒓𝒕𝒊𝒛𝒆𝒅 𝒄𝒐𝒔𝒕𝒔:</h3>

<h3>
	
 ```math
	
 \begin{equation}
   \begin{split}
	

𝑪𝒓𝒆𝒅𝒊𝒕  = 𝒄𝒊  = \quad \sum_{𝒊=1}^{𝒎} 𝒄_𝒊 \quad - \quad  \sum_{𝒊=1}^{𝒎} 𝒂_𝒊  ≥ 𝟎 \\
		
    \end{split}
 \end{equation}
	
```

</h3>
	
<h3> 𝑻𝒉𝒆𝒓𝒆𝒇𝒐𝒓𝒆 , 𝒕𝒉𝒆 𝒂𝒄𝒕𝒖𝒂𝒍 𝒄𝒐𝒔𝒕 𝒊𝒔 𝒃𝒐𝒖𝒏𝒅𝒆𝒅 𝒃𝒚 𝒕𝒉𝒆 𝒕𝒐𝒕𝒂𝒍 𝒂𝒎𝒐𝒓𝒕𝒊𝒛𝒆𝒅 
𝒄𝒐𝒔𝒕 𝑶(𝒂).</h3>
	
<h3>𝑳𝒆𝒕 𝒖𝒔 𝒕𝒂𝒌𝒆 𝒆𝒙𝒂𝒎𝒑𝒍𝒆 𝒐𝒇 𝑫𝒚𝒏𝒂𝒎𝒊𝒄 𝒕𝒂𝒃𝒍𝒆:</h3>

![Screenshot (501)](https://github.com/AvinandanBose/Amortized_Time_Complexity-Theory/assets/38869235/b3e0f937-0fca-44da-8893-d6b36c1eb5ee)

<h3>𝑯𝒆𝒏𝒄𝒆 𝒘𝒆 𝒈𝒆𝒕 `𝒂` 𝒂𝒔 𝟑 𝒊𝒏 𝒎𝒐𝒔𝒕 𝒄𝒂𝒔𝒆𝒔 𝒉𝒆𝒏𝒄𝒆 𝒊𝒇 𝒊𝒕 𝒓𝒖𝒏 𝒂𝒕
𝒏 𝒕𝒊𝒎𝒆𝒔 𝒘𝒆 𝒈𝒆𝒕 𝑶(𝟑𝒏)=𝑶(𝒏).</h3>
	
<h3>𝑨𝒏𝒅 𝒕𝒉𝒆 𝒂𝒄𝒕𝒖𝒂𝒍 𝒄𝒐𝒔𝒕  𝒃𝒐𝒖𝒏𝒅𝒆𝒅 𝒃𝒚 𝒕𝒐𝒕𝒂𝒍 𝒂𝒎𝒐𝒓𝒕𝒊𝒛𝒆𝒅 𝒄𝒐𝒔𝒕 
⟹𝑶(𝒂)=𝑶(𝟑)=𝑶(𝟏).</h3>
	
<ul>
<ul>
<ul>
	
<li><h3> <a href="https://github.com/AvinandanBose/Amortized_Time_Complexity-Theory/blob/main/Amortized%20Time%20Complexity-Accounting%20Method.pdf">𝑨𝒎𝒐𝒓𝒕𝒊𝒛𝒆𝒅 𝑻𝒊𝒎𝒆 𝑪𝒐𝒎𝒑𝒍𝒆𝒙𝒊𝒕𝒚-𝑨𝒄𝒄𝒐𝒖𝒏𝒕𝒊𝒏𝒈 𝑴𝒆𝒕𝒉𝒐𝒅 - 𝑰𝒏 𝑫𝒆𝒕𝒂𝒊𝒍𝒔  </a></h3></li>
	
</ul>
</ul>
</ul>
	
</ul>
	
<h1></h1>
<h1 align="Center">𝑨𝒎𝒐𝒓𝒕𝒊𝒛𝒆𝒅 𝑻𝒊𝒎𝒆 𝑪𝒐𝒎𝒑𝒍𝒆𝒙𝒊𝒕𝒚 − 𝑷𝒐𝒕𝒆𝒏𝒕𝒊𝒂𝒍 𝑴𝒆𝒕𝒉𝒐𝒅</h1>

<ul>
	
<h3>𝑻𝒉𝒆 𝒄𝒐𝒏𝒄𝒆𝒑𝒕 𝒐𝒇 𝒑𝒐𝒕𝒆𝒏𝒕𝒊𝒂𝒍 𝒊𝒔 𝒅𝒆𝒓𝒊𝒗𝒆𝒅 𝒇𝒓𝒐𝒎 𝒑𝒉𝒚𝒔𝒊𝒄𝒔 .
𝑻𝒉𝒆 𝒊𝒅𝒆𝒂 𝒊𝒔 𝒕𝒉𝒂𝒕 𝒂 𝒔𝒚𝒔𝒕𝒆𝒎 𝒄𝒉𝒂𝒏𝒈𝒆𝒔 𝒔𝒕𝒂𝒕𝒆𝒔 𝒂𝒔 𝒑𝒆𝒓
𝒆𝒙𝒕𝒆𝒓𝒏𝒂𝒍 𝒐𝒑𝒆𝒓𝒂𝒕𝒊𝒐𝒏𝒔. 𝑻𝒉𝒆 𝒄𝒉𝒂𝒏𝒈𝒆 𝒐𝒇 𝒔𝒕𝒂𝒕𝒆 𝒄𝒂𝒏 𝒃𝒆 𝒔𝒕𝒐𝒓𝒆𝒅
𝒂𝒔 𝒂 𝒑𝒐𝒕𝒆𝒏𝒕𝒊𝒂𝒍 𝝓, 𝒘𝒉𝒊𝒄𝒉 𝒎𝒂𝒑𝒔 𝒕𝒉𝒆 𝒊𝒏𝒔𝒕𝒂𝒏𝒄𝒆𝒔 𝒐𝒇 𝒂 𝒅𝒂𝒕𝒂
𝒔𝒕𝒓𝒖𝒄𝒕𝒖𝒓𝒆 𝒕𝒐 𝒕𝒉𝒐𝒔𝒆 𝒐𝒇 𝒂 𝒓𝒆𝒂𝒍 𝒏𝒖𝒎𝒃𝒆𝒓. 𝑳𝒆𝒕 𝒄𝒊 𝒃𝒆 𝒕𝒉𝒆 𝒂𝒄𝒕𝒖𝒂𝒍
𝒄𝒐𝒔𝒕 𝒐𝒇 𝒂𝒏 𝒐𝒑𝒆𝒓𝒂𝒕𝒊𝒐𝒏 𝒂𝒏𝒅 𝒕𝒉𝒆 𝒔𝒕𝒂𝒕𝒆𝒔 𝒐𝒇 𝒕𝒉𝒆 𝒔𝒕𝒓𝒖𝒄𝒕𝒖𝒓𝒆 𝒂𝒓𝒆
𝝓𝒊 𝒂𝒏𝒅 𝝓𝒊−𝟏, 𝒕𝒉𝒆𝒏 𝒕𝒉𝒆 𝒂𝒎𝒐𝒓𝒕𝒊𝒛𝒆𝒅 𝒄𝒐𝒔𝒕 𝒄𝒂𝒏 𝒃𝒆 𝒓𝒆𝒑𝒓𝒆𝒔𝒆𝒏𝒕𝒆𝒅
𝒂𝒔 𝒇𝒐𝒍𝒍𝒐𝒘𝒔:</h3>
	
<h3>
	
 ```math
	
 \begin{equation}
   \begin{split}
	

\sum_{𝒊=1}^{𝒎} 𝒂_𝒊  = \sum_{𝒊=1}^{𝒎} 𝒄_𝒊 + 𝝓(𝑫_𝒊) − 𝝓(𝑫_{𝒊−𝟏}) = \sum_{𝒊=1}^{𝒎} 𝒄_𝒊 + \sum_{𝒊=1}^{𝒎} 𝝓(𝑫_𝒊) − 𝝓(𝑫_{𝒊−𝟏})  \\

= \sum_{𝒊=1}^{𝒎} 𝒄_𝒊 + 𝝓(𝑫_𝒎) − 𝝓(𝑫_𝟎) \quad \quad \quad \quad \quad \quad \quad \quad \quad \quad \quad \quad \quad \quad \\
	
		
    \end{split}
 \end{equation}
	
```

</h3>
	
<h3>𝑻𝒉𝒖𝒔, 𝒕𝒉𝒆 𝒂𝒎𝒐𝒓𝒕𝒊𝒛𝒆𝒅 𝒄𝒐𝒔𝒕 𝒊𝒔 𝒕𝒉𝒆 𝒕𝒐𝒕𝒂𝒍 𝒄𝒐𝒔𝒕 𝒑𝒍𝒖𝒔 𝒕𝒉𝒆 𝒅𝒊𝒇𝒇𝒆𝒓𝒆𝒏𝒄𝒆
𝒃𝒆𝒕𝒘𝒆𝒆𝒏 𝒕𝒉𝒆 𝒃𝒆𝒈𝒊𝒏𝒏𝒊𝒏𝒈 𝒂𝒏𝒅 𝒆𝒏𝒅 𝒑𝒐𝒕𝒆𝒏𝒕𝒊𝒂𝒍 𝒐𝒇 𝒕𝒉𝒆 𝒅𝒂𝒕𝒂
𝒔𝒕𝒓𝒖𝒄𝒕𝒖𝒓𝒆.𝑨𝒔 𝝓(𝑫𝒎) 𝒊𝒔 𝒈𝒓𝒆𝒂𝒕𝒆𝒓 𝒕𝒉𝒂𝒏 𝝓(𝑫𝟎), 𝒕𝒉𝒆 𝒂𝒎𝒐𝒓𝒕𝒊𝒛𝒆𝒅
𝒄𝒐𝒔𝒕 𝒊𝒔 𝒖𝒑𝒑𝒆𝒓 𝒃𝒐𝒖𝒏𝒅 𝒐𝒇 𝒕𝒉𝒆 𝒂𝒄𝒕𝒖𝒂𝒍 𝒄𝒐𝒔𝒕.</h3>

<h3 align="Center"><ins>𝑻𝒂𝒌𝒊𝒏𝒈 𝒕𝒉𝒆 𝒆𝒙𝒂𝒎𝒑𝒍𝒆 𝒐𝒇 𝑫𝒚𝒏𝒂𝒎𝒊𝒄 𝑻𝒂𝒃𝒍𝒆</ins></h3>
	
<h3>𝝓 = 𝟐 × 𝑵𝒐. 𝒐𝒇 𝒊𝒕𝒆𝒎𝒔 𝒊𝒏 𝒕𝒉𝒆 𝒂𝒓𝒓𝒂𝒚 − 𝒄𝒂𝒑𝒂𝒄𝒊𝒕𝒚 𝒐𝒇 𝒕𝒉𝒆 𝒂𝒓𝒓𝒂𝒚.</h3>
	
![Screenshot (503)](https://github.com/AvinandanBose/Amortized_Time_Complexity-Theory/assets/38869235/6eb38ae3-c11b-4601-94d2-467b04da9648)
	
<ul>
<ul>
<ul>
	
<li><h3> <a href="https://github.com/AvinandanBose/Amortized_Time_Complexity-Theory/blob/main/Amortized%20Time%20Complexity%20-%20Potential%20Method.pdf">𝑨𝒎𝒐𝒓𝒕𝒊𝒛𝒆𝒅 𝑻𝒊𝒎𝒆 𝑪𝒐𝒎𝒑𝒍𝒆𝒙𝒊𝒕𝒚-𝑷𝒐𝒕𝒆𝒏𝒕𝒊𝒂𝒍 𝑴𝒆𝒕𝒉𝒐𝒅 - 𝑰𝒏 𝑫𝒆𝒕𝒂𝒊𝒍𝒔  </a></h3></li>
	
</ul>
</ul>
</ul>
	
<h3>𝑨𝒔 𝒘𝒆 𝒔𝒆𝒆 𝒂𝒍𝒍 𝒉𝒂𝒗𝒆 𝟑 𝒂𝒏𝒅 𝒊𝒇 𝒊𝒕 𝒓𝒖𝒏𝒔 𝒖𝒑𝒕𝒐 𝒏 𝒕𝒊𝒎𝒆𝒔 𝒕𝒉𝒆𝒏 𝒊𝒕 
𝒈𝒆𝒏𝒆𝒓𝒂𝒕𝒆𝒔 𝑶(𝟑𝒏)=𝑶(𝒏). 𝑻𝒉𝒆 𝒂𝒎𝒐𝒓𝒕𝒊𝒛𝒆𝒅 𝑪𝒐𝒎𝒑𝒍𝒆𝒙𝒊𝒕𝒚=
𝑶(𝟑)=𝑶(𝟏)  𝒊.𝒆.𝒆𝒂𝒄𝒉 𝒂𝒕 𝒄𝒐𝒏𝒔𝒕𝒂𝒏𝒕 𝒕𝒊𝒎𝒆.</h3>
	
<h3>𝑨𝒔 𝒘𝒆 𝒔𝒆𝒆 𝒂𝒍𝒍 𝒉𝒂𝒗𝒆 𝟑 𝒂𝒏𝒅 𝒊𝒇 𝒊𝒕 𝒓𝒖𝒏𝒔 𝒖𝒑𝒕𝒐 𝒏 𝒕𝒊𝒎𝒆𝒔 𝒕𝒉𝒆𝒏 𝒊𝒕
𝒈𝒆𝒏𝒆𝒓𝒂𝒕𝒆𝒔 𝑶(𝟑𝒏) = 𝑶(𝒏). 𝑻𝒉𝒆 𝒂𝒎𝒐𝒓𝒕𝒊𝒛𝒆𝒅 𝑪𝒐𝒎𝒑𝒍𝒆𝒙𝒊𝒕𝒚 =
𝑶(𝟑) = 𝑶(𝟏) 𝒊. 𝒆. 𝒆𝒂𝒄𝒉 𝒂𝒕 𝒄𝒐𝒏𝒔𝒕𝒂𝒏𝒕 𝒕𝒊𝒎𝒆.</h3>
	
<h3>𝑵𝒐𝒘,𝒊𝒇 𝒘𝒆 𝒔𝒆𝒆:</h3>

<h3>
	
 ```math
	
 \begin{equation}
   \begin{split}
	

𝝓 = 𝟐 × \quad 𝑵𝒐. \quad 𝒐𝒇 \quad 𝒊𝒕𝒆𝒎𝒔 \quad 𝒊𝒏 \quad 𝒕𝒉𝒆 \quad 𝒂𝒓𝒓𝒂𝒚 \quad − \quad 𝒄𝒂𝒑𝒂𝒄𝒊𝒕𝒚 \quad 𝒐𝒇 \quad 𝒕𝒉𝒆 \quad 𝒂𝒓𝒓𝒂𝒚. \\

𝒊𝒇 \quad 𝒏𝒖𝒎𝒃𝒆𝒓 \quad 𝒐𝒇 \quad 𝒊𝒕𝒆𝒎𝒔 \quad =  \quad 𝒊 \quad 𝒂𝒏𝒅 \quad 𝒄𝒂𝒑𝒂𝒄𝒊𝒕𝒚 \quad 𝒐𝒇 \quad 𝒕𝒉𝒆  \quad 𝒂𝒓𝒓𝒂𝒚: 𝟐^{⌈𝐥𝐨𝐠_𝟐(𝒊)⌉}\\
𝝓 = 𝟐𝒊 − 𝟐^{⌈𝐥𝐨𝐠_𝟐(𝒊)⌉} \quad \quad \quad \quad \quad \quad \quad \quad \quad \quad \quad \quad \quad \quad \quad \quad \quad \quad \\
	
		
    \end{split}
 \end{equation}
	
```

</h3>
	
<h3>𝑨𝒏𝒅 𝒇𝒓𝒐𝒎 𝒕𝒉𝒆 𝒂𝒃𝒐𝒗𝒆 𝒕𝒂𝒃𝒍𝒆 𝒘𝒆 𝒈𝒆𝒕 𝒕𝒘𝒐 𝒄𝒂𝒔𝒆𝒔:</h3>
<h3>𝑪𝒊 = 𝒊 , 𝒘𝒉𝒆𝒏 𝒊 − 𝟏 𝒊𝒔 𝒂𝒏 𝑨𝒄𝒕𝒖𝒂𝒍 𝑷𝒐𝒘𝒆𝒓 𝒐𝒇 𝟐.</h3>
<h3>𝑪𝒊 = 𝟏 , 𝒘𝒉𝒆𝒏 𝒊 − 𝟏 𝒊𝒔 𝒏𝒐𝒕 𝒂𝒏 𝑨𝒄𝒕𝒖𝒂𝒍 𝑷𝒐𝒘𝒆𝒓 𝒐𝒇 𝟐.</h3>
	
![Screenshot (505)](https://github.com/AvinandanBose/Amortized_Time_Complexity-Theory/assets/38869235/e1b7e910-256d-4705-a6b1-5af522fde483)
![Screenshot (506)](https://github.com/AvinandanBose/Amortized_Time_Complexity-Theory/assets/38869235/970a3642-2932-487a-8e10-39d972b94e66)


<h3>𝑪𝒂𝒔𝒆𝟏: 𝒘𝒉𝒆𝒏 𝒊 − 𝟏 𝒊𝒔 𝒂𝒏 𝑨𝒄𝒕𝒖𝒂𝒍 𝑷𝒐𝒘𝒆𝒓 𝒐𝒇 𝟐,
𝑨𝒄𝒕𝒖𝒂𝒍 𝑪𝒐𝒔𝒕(𝑪𝒊) 𝒊𝒔 𝒊 : </h3>
	

<h3>
	
 ```math
	
 \begin{equation}
   \begin{split}
	

𝒂_𝒊 =  𝒊 + 𝟐𝒊 − 𝟐^{⌈𝐥𝐨𝐠𝟐𝒊⌉} − (𝟐(𝒊 − 𝟏) − 𝟐^{⌈𝐥𝐨𝐠_𝟐(𝒊)−𝟏⌉}) = 𝒊 + 𝟐 − 𝟐^{⌈𝐥𝐨𝐠_𝟐(𝒊)⌉} + 𝟐^{⌈𝐥𝐨𝐠_𝟐(𝒊−𝟏)⌉} =𝟑 

	
		
    \end{split}
 \end{equation}
	
```

</h3>
	
<ul>
<ul>
<ul>
	
<li><h3> <a href="https://github.com/AvinandanBose/Amortized_Time_Complexity-Theory/blob/main/Amortized%20Time%20Complexity%20-%20Potential%20Method.pdf">𝑨𝒎𝒐𝒓𝒕𝒊𝒛𝒆𝒅 𝑻𝒊𝒎𝒆 𝑪𝒐𝒎𝒑𝒍𝒆𝒙𝒊𝒕𝒚-𝑷𝒐𝒕𝒆𝒏𝒕𝒊𝒂𝒍 𝑴𝒆𝒕𝒉𝒐𝒅 - 𝑰𝒏 𝑫𝒆𝒕𝒂𝒊𝒍𝒔  </a></h3></li>
	
</ul>
</ul>
</ul>
	
<h3>𝑪𝒂𝒔𝒆𝟐: 𝒘𝒉𝒆𝒏 𝒊 − 𝟏 𝒊𝒔 𝒏𝒐𝒕 𝒂𝒏 𝑨𝒄𝒕𝒖𝒂𝒍 𝑷𝒐𝒘𝒆𝒓 𝒐𝒇 𝟐,
𝑨𝒄𝒕𝒖𝒂𝒍 𝑪𝒐𝒔𝒕(𝑪𝒊) 𝒊𝒔 𝟏 : </h3>
	
<h3>
	
 ```math
	
 \begin{equation}
   \begin{split}
	
𝒂_𝒊 = 𝟏 + 𝟐𝒊 − 𝟐^{⌈𝐥𝐨𝐠_𝟐(𝒊)⌉} − (𝟐(𝒊 − 𝟏) − 𝟐^{⌈𝐥𝐨𝐠_𝟐(𝒊−𝟏)⌉}) = 𝟏 + 𝟐 − 𝟐^{⌈𝐥𝐨𝐠_𝟐(𝒊)⌉} + 𝟐^{⌈𝐥𝐨𝐠_𝟐(𝒊−𝟏)⌉} =𝟑 


		
    \end{split}
 \end{equation}
	
```

</h3>
	
<ul>
<ul>
<ul>
	
<li><h3> <a href="https://github.com/AvinandanBose/Amortized_Time_Complexity-Theory/blob/main/Amortized%20Time%20Complexity%20-%20Potential%20Method.pdf">𝑨𝒎𝒐𝒓𝒕𝒊𝒛𝒆𝒅 𝑻𝒊𝒎𝒆 𝑪𝒐𝒎𝒑𝒍𝒆𝒙𝒊𝒕𝒚-𝑷𝒐𝒕𝒆𝒏𝒕𝒊𝒂𝒍 𝑴𝒆𝒕𝒉𝒐𝒅 - 𝑰𝒏 𝑫𝒆𝒕𝒂𝒊𝒍𝒔  </a></h3></li>
	
</ul>
</ul>
</ul>

<h3>𝑨𝒔 𝒘𝒆 𝒔𝒆𝒆 𝒂𝒍𝒍 𝒉𝒂𝒗𝒆 𝟑 𝒂𝒏𝒅 𝒊𝒇 𝒊𝒕 𝒓𝒖𝒏𝒔 𝒖𝒑𝒕𝒐 𝒏 𝒕𝒊𝒎𝒆𝒔 𝒕𝒉𝒆𝒏 𝒊𝒕
𝒈𝒆𝒏𝒆𝒓𝒂𝒕𝒆𝒔 𝑶(𝟑𝒏) = 𝑶(𝒏). 𝑻𝒉𝒆 𝒂𝒎𝒐𝒓𝒕𝒊𝒛𝒆𝒅 𝒄𝒐𝒔𝒕 =
𝑶(𝟑) = 𝑶(𝟏) 𝒊. 𝒆. 𝒆𝒂𝒄𝒉 𝒂𝒕 𝒄𝒐𝒏𝒔𝒕𝒂𝒏𝒕 𝒕𝒊𝒎𝒆.</h3>
	
<ul>
<ul>
<ul>
	
<li><h3> <a href="https://github.com/AvinandanBose/Amortized_Time_Complexity-Theory/blob/main/Amortized%20Time%20Complexity%20-%20Potential%20Method.pdf">𝑨𝒎𝒐𝒓𝒕𝒊𝒛𝒆𝒅 𝑻𝒊𝒎𝒆 𝑪𝒐𝒎𝒑𝒍𝒆𝒙𝒊𝒕𝒚-𝑷𝒐𝒕𝒆𝒏𝒕𝒊𝒂𝒍 𝑴𝒆𝒕𝒉𝒐𝒅 - 𝑰𝒏 𝑫𝒆𝒕𝒂𝒊𝒍𝒔  </a></h3></li>
	
</ul>
</ul>
</ul>
	
	


</ul>

